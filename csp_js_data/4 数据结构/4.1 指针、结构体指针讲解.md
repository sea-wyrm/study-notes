## 第3章 链表及链式栈、链式队列

### 指针

计算机程序在存储数据时必须跟踪的3种基本属性：

- 信息存储在何处
- 存储的值为多少
- 存储的信息是什么类型

> 以往，我们用了一种策略来达到以上的目的：定义一个简单变量。声明语句指出了值的类型和符号名，还让程序为值分配内存，并在内部跟踪该内存单元。



#### 指针的概念

现在，有一种新的策略，它在开发C++类时非常重要。

这种策略以指针为基础，**指针是一个变量，其存储的是值的地址，而不是值本身。**

> 如何找到常规变量的地址：对变量应用取地址符(`&`)，就可以获得它的位置。如果`home`是一个变量，那么`&home`是它的地址。
>
> 地址可以cout输出，cout使用十六进制表示法，这也是常用于内存的表示法

**指针（Pointer）：变量的地址，通过它能找到以它为地址的内存单元。**



#### 指针与值的关系

使用常规的变量时，值是指定的量，而地址为派生量。

这种新的策略中，地址是指定的量，而值是派生量。

一种特殊类型的变量——**指针**用于存储值的地址。因此，指针名表示的是地址。

`*`运算符被称为间接值（indirect value）或解除引用运算符（dereferencing），将其用于指针，可以得到该地址处存储的值。

> C++根据上下文来确定*指的是乘法还是解除引用。

假设`manly`是一个指针，则`manly`表示的是一个地址，而`*manly`表示存储在这个地址中的值。`*manly`与常规int变量等效。

```C++
// 值的定义
int a;

// 指针的定义：p_a 是 int* 类型的指针，是整型变量a的地址
int* p_a = &a;

// 赋值
a = 6;		// 给变量a赋值
*p_a = 6;	// 修改指针p_a指向的值
*p_a = *p_a + 2;	// 修改指针p_a指向的变量的值

// 读取值
cout << a;
cout << *p_a;	// *运算符可获得指针指向的值

// 读取指针
cout << p_a;
cout << &a;		// &运算符可获得值的地址
```

> 传统上，C程序员使用`int *ptr;` 强调*ptr是一个int类型的值。
>
> 而很多C++程序员使用`int* ptr;` 强调int*是一种类型：指向int的指针。
>
> 在哪里添加空格对于编译器来说没有任何区别。



#### 指针的危险

在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。

为数据提供空间是一个独立的步骤。

示例：

```C++
long* fellow;		// create a pointer-to-long
*fellow = 23333;	// place a value in never-never land
```

fellow是一个指针，但没有初始化，所以它可能指向任何位置。如果指向系统代码的位置，有可能导致难以跟踪的bug。

>  也称为空对象。

**一定要在对指针应用解除引用运算符`*`之前，将指针初始化为一个确定的、恰当的地址。**



#### `new ` 和 `delete`管理动态内存

指针经常用于在运行时分配未命名的内存以存储值。这种情况下，只能通过指针来访问内存。

在C语言中，可以用库函数`malloc()`来分配内存。

在C++中也可以用，但更常用`new`运算符。



##### `new`分配内存

在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值。

程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长度正确的内存块，并返回该内存块的地址。

示例：

```C++
int* pn = new int;
```

`new int`告诉程序，需要适合存储int类型的内存。new运算符根据类型来确定需要多少字节的内存。然后它找到这样的内存，并返回其地址。接下来，将地址赋给pn，pn是被声明为指向int的指针。

> 现在，pn是地址，而*pn是存储在那里的值。

原本的方法示例：

```C++
int data;
int* pd = &data; 
```



`new`分配的内存块通常与常规变量声明分配的内存块不同。变量data和pd的值都存储在被称为栈<kbd>stack</kbd>的内存区域中，而new从被称为堆<kbd>heap</kbd>或自由存储区<kbd>free store</kbd>的内存区域分配内存。



##### `delete`释放内存

使用`delete`时，后面要写上指向内存块的指针。

示例：

```C++
int* pd = new int;
*pd = 1000;
// ...
delete pd;
```

这将释放pd指向的内存，但不会删除指针pd本身。例如，可以将pd重新指向另一个新分配的内存块。

一定要配对地使用new和delete，否则将发生**内存泄漏**<kbd>memory leak</kbd>，也就是说，被分配的内存将再也无法使用。

> 也不能释放已经释放的内存块，这样做的标准是不确定的，什么情况都有可能发生。
>
> 也不能用delete来释放用声明变量所获得的内存。



##### `new`创建动态数组

在编译时给数组分配内存被称为静态联编<kbd>static binding</kbd>。

使用new时，可以在程序运行过程中选择是否创建或自定义创建数组的长度，这被称为动态联编<kbd>dynamic binding</kbd>。意味着数组是在运行时创建的。这种数组被称为动态数组<kbd>dynamic array</kbd>。

创建动态数组示例：

```C++
int* pt = new int[10];	// get a block of 10 ints
```

删除动态数组示例：

```C++
delete [] pt;	// free a dynamic array
```



##### 动态数组的使用

C/C++中，数组和指针是等价的，可以把指针当作数组名使用。

示例：

```C++
double* pd = array;
```

和所有的数组一样，存在下列的等式：

```C++
pd == array == &array[0]
```



##### 数组和指针的不同

- 可以修改指针的值，而数组名是常量
- 对数组使用sizeof将得到数组的长度，而对指针使用sizeof将得到指针的长度，即使指针指向的是一个数组。

> 对数组取地址时，地址名也不会被解释为其地址。数组名被解释为其第一个元素的地址，而对数组名应用取地址符时，得到的是整个数组的地址。



##### 指针算术

C++允许将整数与指针相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。

示例：

```C++
double* pd = new double;
pd = pd - 1;	// 减少8个字节

int* pi = new int;
pi = pi - 1;	// 减少4个字节
```



##### 指针和字符串

```C++
char* s = "bird";
```

`"bird"`实际上表示的是字符串的地址，因此这条语句把地址赋值给了s指针。

可以通过`strcpy()`和`new`，获得字符串的两个独立副本。



`=`复制字符串示例：

```C++
string animal = "fox";
string ps;
ps = animal;
```

> 这样ps与animal的地址相同，也就是说，复制的是地址，不是值。



`new`复制字符串示例：

```C++
ps = new char[strlen(animal) + 1]; // get new storage
```



`strcpy()`复制字符串示例：

```C++
strcpy(ps, aniaml);	// copy string to new storage
```

> `strcpy()`有两个参数，第一个参数是目标字符串的地址，第二个参数是要复制的字符串的地址



##### `new`创建动态结构

```C++
struct inflatable{
    string name;
    int year;
};

inflatable* pi = new inflatable;
```

> 这将足以存储inflatable结构的一块可用内存的地址赋给pi。



访问结构成员的方法：

- 创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构没有名称，只知道地址。C++专门为这种情况提供了一个运算符：箭头成员运算符`->`，可用于指向结构的指针，就像点运算符可以用于结构名一样。例如，如果pi指向一个inflatable结构，则`pd->name`是被指向的结构的name成员。

<img src="/Users/wyrm/Downloads/IMG_0230.jpg" alt="IMG_0230" style="zoom: 33%;" />

- 另一种方法是，如果pi是指向inflatable的指针，那么*pi就是被指向的值——结构本身。

  由于*pi是一个结构，因此`(*pi).year`是该结构的year成员。



#### 自动存储、静态存储和动态存储

1. 自动存储

在函数内部定义的常规变量使用自动存储空间，被称为自动变量 （automatic variable），只在包含它的代码中有效，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。

自动变量通常存储在栈中。

2. 静态存储

静态存储是整个程序执行期间都存在的存储方式。使变量成为静态 的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用 关键字 `static`。

3. 动态存储

`new` 和 `delete` 运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap）。该内存池同用于静态变量和自动变量的内存是分开的。



#### 类型组合：指针数组（指向指针的指针）

```C++
#include <iostream>
using namespace std;

struct pd{
    int year;
    string name;
};

int main(){
    pd s1 = {1,"Andy"}, s2 = {2,"Bob"}, s3 = {3, "Candy"};
    pd *p[3] = {&s1, &s2, &s3};
    cout << s1.name << endl;
    cout << p[1]->name << endl;
    cout << (*p[2]).name << endl;
    pd **pp = p;
    cout << (*p[0]).year << endl;
    return 0;
}
```



